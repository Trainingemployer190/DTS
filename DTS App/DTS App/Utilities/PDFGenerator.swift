import Foundation
import SwiftUI
import PDFKit

#if canImport(UIKit)
import UIKit
#endif
#if canImport(AVFoundation)
import AVFoundation
#endif

class PDFGenerator {
    static let shared = PDFGenerator()

    private init() {}

    // MARK: - Quote PDF Generation (Enhanced)
    #if canImport(UIKit)
    func generateQuotePDF(
        quote: QuoteDraft,
        settings: AppSettings,
        breakdown: PricingEngine.PriceBreakdown,
        photos: [UIImage]? = nil
    ) -> Data? {
        let pageWidth: CGFloat = 612  // 8.5in @ 72dpi
        let pageHeight: CGFloat = 792 // 11in @ 72dpi
        let margin: CGFloat = 18      // Even smaller margins for more space
        let contentWidth = pageWidth - margin * 2
        let headerHeight: CGFloat = 55 // Slightly larger for bigger title font
        let accent = UIColor(red: 0.12, green: 0.37, blue: 0.82, alpha: 1.0)
        let lightFill = UIColor(white: 0.96, alpha: 1.0)

        let renderer = UIGraphicsPDFRenderer(bounds: CGRect(x: 0, y: 0, width: pageWidth, height: pageHeight))

        let titleFont = UIFont.boldSystemFont(ofSize: 30)     // Much larger for header
        let sectionFont = UIFont.boldSystemFont(ofSize: 18)   // Bigger section headers
        let labelFont = UIFont.systemFont(ofSize: 15)         // Larger body text
        let valueFont = UIFont.boldSystemFont(ofSize: 15)     // Bold values for emphasis
        let smallFont = UIFont.systemFont(ofSize: 13)         // Larger small text
        let bigNumberFont = UIFont.boldSystemFont(ofSize: 28) // Much larger numbers

        func currency(_ value: Double) -> String {
            let f = NumberFormatter()
            f.numberStyle = .currency
            f.locale = Locale.current
            return f.string(from: NSNumber(value: value)) ?? "$0.00"
        }

        func percent(_ value: Double) -> String { String(format: "%.1f%%", value * 100) }

        var pageIndex = 0

        func drawHeader(context: UIGraphicsPDFRendererContext) {
            let ctx = UIGraphicsGetCurrentContext()!
            // Bar
            ctx.setFillColor(accent.cgColor)
            ctx.fill(CGRect(x: 0, y: 0, width: pageWidth, height: headerHeight))
            // Title
            let titleAttr: [NSAttributedString.Key: Any] = [
                .font: titleFont,
                .foregroundColor: UIColor.white
            ]
            ("DTS Quote" as NSString).draw(at: CGPoint(x: margin, y: 14), withAttributes: titleAttr)
            // Meta (right)
            let metaAttr: [NSAttributedString.Key: Any] = [
                .font: smallFont,
                .foregroundColor: UIColor.white
            ]
            let dateStr = Date().formatted(.medium)
            ("Date: \(dateStr)" as NSString).draw(at: CGPoint(x: pageWidth - margin - 160, y: 8), withAttributes: metaAttr)
            let quoteNo = String(quote.localId.uuidString.prefix(8))
            ("Quote #: \(quoteNo)" as NSString).draw(at: CGPoint(x: pageWidth - margin - 160, y: 24), withAttributes: metaAttr)
        }

        func drawFooter(context: UIGraphicsPDFRendererContext) {
            let ctx = UIGraphicsGetCurrentContext()!
            ctx.setStrokeColor(UIColor.systemGray4.cgColor)
            ctx.setLineWidth(0.5)
            ctx.move(to: CGPoint(x: margin, y: pageHeight - margin - 8))
            ctx.addLine(to: CGPoint(x: pageWidth - margin, y: pageHeight - margin - 8))
            ctx.strokePath()

            let footAttr: [NSAttributedString.Key: Any] = [
                .font: smallFont,
                .foregroundColor: UIColor.darkGray
            ]
            ("Generated by DTS App" as NSString).draw(at: CGPoint(x: margin, y: pageHeight - margin - 4), withAttributes: footAttr)
            ("Page \(pageIndex)" as NSString).draw(at: CGPoint(x: pageWidth - margin - 60, y: pageHeight - margin - 4), withAttributes: footAttr)
        }

        func newPage(_ context: UIGraphicsPDFRendererContext, _ y: inout CGFloat) {
            pageIndex += 1
            context.beginPage()
            drawHeader(context: context)
            drawFooter(context: context)
            y = headerHeight + margin
        }

        func drawSectionHeader(_ text: String, y: inout CGFloat) {
            let barWidth: CGFloat = 5  // Slightly thicker bar
            let barHeight: CGFloat = 22
            let ctx = UIGraphicsGetCurrentContext()!
            ctx.setFillColor(accent.cgColor)
            ctx.fill(CGRect(x: margin, y: y + 3, width: barWidth, height: barHeight))
            let attr: [NSAttributedString.Key: Any] = [
                .font: sectionFont,
                .foregroundColor: UIColor.black
            ]
            (text as NSString).draw(at: CGPoint(x: margin + barWidth + 10, y: y), withAttributes: attr)
            y += 32  // More space for larger section headers
        }

        func drawKeyValue(_ key: String, _ value: String, y: inout CGFloat) {
            let keyAttr: [NSAttributedString.Key: Any] = [
                .font: labelFont,
                .foregroundColor: UIColor.darkGray
            ]
            let valueAttr: [NSAttributedString.Key: Any] = [
                .font: valueFont,
                .foregroundColor: UIColor.black
            ]
            let keyRect = CGRect(x: margin, y: y, width: contentWidth * 0.45, height: 22)
            let valueRect = CGRect(x: margin + contentWidth * 0.5, y: y, width: contentWidth * 0.5, height: 22)
            (key as NSString).draw(in: keyRect, withAttributes: keyAttr)
            (value as NSString).draw(in: valueRect, withAttributes: valueAttr)
            y += 24  // More space for larger fonts
        }

        func drawSummaryBoxes(y: inout CGFloat) {
            let boxPadding: CGFloat = 20  // More padding
// Changed per instructions:
            let boxHeight: CGFloat = 260  // Increased height to keep all rows (incl. Tax) inside
            let boxSpacing: CGFloat = 16  // More space between boxes
            let halfWidth = (contentWidth - boxSpacing) / 2

            // Left box: Summary (Total + organized breakdown)
            let leftRect = CGRect(x: margin, y: y, width: halfWidth, height: boxHeight)
            let leftPath = UIBezierPath(roundedRect: leftRect, cornerRadius: 10)
            lightFill.setFill(); leftPath.fill()

            let titleAttr: [NSAttributedString.Key: Any] = [ .font: sectionFont, .foregroundColor: UIColor.black ]
            ("Summary" as NSString).draw(at: CGPoint(x: leftRect.minX + boxPadding, y: leftRect.minY + boxPadding), withAttributes: titleAttr)

            let bigAttr: [NSAttributedString.Key: Any] = [ .font: bigNumberFont, .foregroundColor: accent ]
            (currency(breakdown.totalPrice) as NSString).draw(at: CGPoint(x: leftRect.minX + boxPadding, y: leftRect.minY + 45), withAttributes: bigAttr)

            // Separator under total
            let ctx = UIGraphicsGetCurrentContext()!
            ctx.setStrokeColor(UIColor.systemGray4.cgColor)
            ctx.setLineWidth(0.5)
            ctx.move(to: CGPoint(x: leftRect.minX + boxPadding, y: leftRect.minY + 75))
            ctx.addLine(to: CGPoint(x: leftRect.maxX - boxPadding, y: leftRect.minY + 75))
            ctx.strokePath()

            // Two-column key/value layout (fixed column widths, clipped to avoid wrapping)
            let labelAttr: [NSAttributedString.Key: Any] = [ .font: smallFont, .foregroundColor: UIColor.darkGray ]
            let valueParagraph = NSMutableParagraphStyle(); valueParagraph.alignment = .right; valueParagraph.lineBreakMode = .byClipping
            let valueAttr: [NSAttributedString.Key: Any] = [ .font: valueFont, .foregroundColor: UIColor.black, .paragraphStyle: valueParagraph ]

            let rowStartY = leftRect.minY + 85
            let rowHeight: CGFloat = 20

            let contentInnerWidth = leftRect.width - (boxPadding * 2)
            let labelWidth = contentInnerWidth * 0.58
            let valueWidth = contentInnerWidth - labelWidth
            let labelX = leftRect.minX + boxPadding
            let valueX = labelX + labelWidth

            func drawRow(_ label: String, _ value: String, _ index: Int) {
                let yPos = rowStartY + CGFloat(index) * rowHeight
                let labelRect = CGRect(x: labelX, y: yPos, width: labelWidth, height: rowHeight)
                let valueRect = CGRect(x: valueX, y: yPos, width: valueWidth, height: rowHeight)
                (label as NSString).draw(in: labelRect, withAttributes: labelAttr)
                (value as NSString).draw(in: valueRect, withAttributes: valueAttr)
            }

            // Use PricingEngine's subtotal (includes additional items)
            let materials = breakdown.materialsCost
            let labor = breakdown.laborCost
            let additional = breakdown.additionalItemsCost
            let subtotal = breakdown.subtotal
            // Markup and commission remain for display
            let markup = breakdown.markupAmount
            let commission = breakdown.commissionAmount
            let preTaxSubtotal = subtotal + markup + commission
            let tax = breakdown.taxAmount

            var rowIndex = 0
            // Base costs
            drawRow("Materials", currency(materials), rowIndex); rowIndex += 1
            drawRow("Labor", currency(labor), rowIndex); rowIndex += 1
            if additional > 0.001 { drawRow("Additional Items", currency(additional), rowIndex); rowIndex += 1 }

            // Subtotal & add-ons
            drawRow("Subtotal", currency(subtotal), rowIndex); rowIndex += 1
            drawRow("Markup (\(percent(quote.markupPercent)))", currency(markup), rowIndex); rowIndex += 1
            drawRow("Commission (\(percent(quote.salesCommissionPercent)))", currency(commission), rowIndex); rowIndex += 1

            // Pre-tax and tax
            drawRow("Pre-Tax Subtotal", currency(preTaxSubtotal), rowIndex); rowIndex += 1
            drawRow("Tax (\(percent(settings.taxRate)))", currency(tax), rowIndex); rowIndex += 1

            // Right box: Price per Foot (separate for gutters and guard when applicable)
            let rightRect = CGRect(x: leftRect.maxX + boxSpacing, y: y, width: halfWidth, height: boxHeight)
            let rightPath = UIBezierPath(roundedRect: rightRect, cornerRadius: 10)
            lightFill.setFill(); rightPath.fill()

            if quote.includeGutterGuard && quote.gutterGuardFeet > 0 {
                // Calculate effective footage including fittings (Bug 2 Fix)
                let effectiveGutterFeet = quote.gutterFeet + quote.downspoutFeet +
                    Double(quote.aElbows + quote.bElbows + quote.twoCrimp + quote.fourCrimp)
                let guardFeet = quote.gutterGuardFeet

                // Use the actual breakdown values from PricingEngine for accurate calculations
                // IMPORTANT: Add fittings (elbows/crimps) and hangers to the gutter materials bucket so
                // component totals sum exactly to the overall total.
                let totalElbows = quote.aElbows + quote.bElbows + quote.twoCrimp + quote.fourCrimp
                let elbowUnitCost = quote.isRoundDownspout ? settings.costPerRoundElbow : settings.costPerElbow
                let elbowsCost = Double(totalElbows) * elbowUnitCost
                let hangersCost = Double(quote.hangersCount) * settings.costPerHanger

                let gutterMaterialsCost = breakdown.gutterMaterialsCost + breakdown.downspoutMaterialsCost
                let guardMaterialsCost = breakdown.gutterGuardCost

                // Use actual labor costs from breakdown instead of estimates
                let actualGutterLabor = breakdown.gutterLaborCost
                let actualGuardLabor = breakdown.gutterGuardLaborCost

                // Compute gutter base cost with elbows, hangers and additional labor items included (per instructions)
                let gutterBaseCost = gutterMaterialsCost + actualGutterLabor + elbowsCost + hangersCost + breakdown.additionalItemsCost
                let guardBaseCost = guardMaterialsCost + actualGuardLabor

                // Add markup per component before distributing commission and tax
                let gutterTotalBeforeAddOns = gutterBaseCost + breakdown.gutterMarkupAmount
                let guardTotalBeforeAddOns = guardBaseCost + breakdown.guardMarkupAmount

                // Distribute only commission and tax proportionally (markup already applied per component)
                let additionalCosts = breakdown.commissionAmount + breakdown.taxAmount

                let totalBaseWithMarkup = gutterTotalBeforeAddOns + guardTotalBeforeAddOns
                let gutterProportion = totalBaseWithMarkup > 0 ? gutterTotalBeforeAddOns / totalBaseWithMarkup : 0.5
                let guardProportion = 1.0 - gutterProportion

                let gutterTotalCost = gutterTotalBeforeAddOns + (additionalCosts * gutterProportion)
                let guardTotalCost = guardTotalBeforeAddOns + (additionalCosts * guardProportion)

                ("Price Analysis" as NSString).draw(at: CGPoint(x: rightRect.minX + boxPadding, y: rightRect.minY + boxPadding), withAttributes: titleAttr)

                // Blue color for gutters price (matching UI) - larger font
                let gutterPriceAttr: [NSAttributedString.Key: Any] = [ .font: valueFont, .foregroundColor: UIColor.systemBlue ]
                ("Gutters: \(currency(gutterTotalCost / (effectiveGutterFeet > 0 ? effectiveGutterFeet : 1)))/ft" as NSString).draw(at: CGPoint(x: rightRect.minX + boxPadding, y: rightRect.minY + 45), withAttributes: gutterPriceAttr)

                // Green color for guard price (matching UI) - larger font
                let guardPriceAttr: [NSAttributedString.Key: Any] = [ .font: valueFont, .foregroundColor: UIColor.systemGreen ]
                ("Guard: \(currency(guardFeet > 0 ? guardTotalCost / guardFeet : 0))/ft" as NSString).draw(at: CGPoint(x: rightRect.minX + boxPadding, y: rightRect.minY + 70), withAttributes: guardPriceAttr)

                let verySmallAttr: [NSAttributedString.Key: Any] = [ .font: UIFont.systemFont(ofSize: 12), .foregroundColor: UIColor.darkGray ]
                ("\(String(format: "%.1f", effectiveGutterFeet))ft effective gutters, \(String(format: "%.1f", guardFeet))ft guard" as NSString).draw(at: CGPoint(x: rightRect.minX + boxPadding, y: rightRect.minY + 100), withAttributes: verySmallAttr)
            } else {
                // Show single price per foot (original behavior)
                ("Price / ft" as NSString).draw(at: CGPoint(x: rightRect.minX + boxPadding, y: rightRect.minY + boxPadding), withAttributes: titleAttr)
                (currency(breakdown.pricePerFoot) as NSString).draw(at: CGPoint(x: rightRect.minX + boxPadding, y: rightRect.minY + 38), withAttributes: bigAttr)
            }

            y += boxHeight + 20  // Slightly increased spacing after boxes
        }

        func drawSignatureArea(y: inout CGFloat) {
            let labelAttr: [NSAttributedString.Key: Any] = [ .font: labelFont, .foregroundColor: UIColor.darkGray ]
            let lineWidth: CGFloat = (contentWidth - 20) / 2
            let lineY = y + 18
            let ctx = UIGraphicsGetCurrentContext()!
            ctx.setStrokeColor(UIColor.systemGray3.cgColor)
            ctx.setLineWidth(1)
            // Left line (Client Signature)
            ctx.move(to: CGPoint(x: margin, y: lineY))
            ctx.addLine(to: CGPoint(x: margin + lineWidth, y: lineY))
            ctx.strokePath()
            ("Client Signature" as NSString).draw(at: CGPoint(x: margin, y: lineY + 4), withAttributes: labelAttr)
            // Right line (Date)
            ctx.move(to: CGPoint(x: margin + lineWidth + 20, y: lineY))
            ctx.addLine(to: CGPoint(x: margin + lineWidth + 20 + lineWidth, y: lineY))
            ctx.strokePath()
            ("Date" as NSString).draw(at: CGPoint(x: margin + lineWidth + 20, y: lineY + 4), withAttributes: labelAttr)
            y += 48
        }

        let data = renderer.pdfData { context in
            var y: CGFloat = 0
            // Reserve space above the footer so content doesn't overlap it
            let bottomLimit = pageHeight - margin - 16 // Reduced from 24 to 16
            func ensureSpace(_ height: CGFloat, y: inout CGFloat) {
                if y + height > bottomLimit { newPage(context, &y) }
            }

            newPage(context, &y)

            // Client
            drawSectionHeader("Client", y: &y)
            ensureSpace(20, y: &y); drawKeyValue("Name", quote.clientName.isEmpty ? "-" : quote.clientName, y: &y)
            ensureSpace(20, y: &y); drawKeyValue("Address", quote.clientAddress.isEmpty ? "-" : quote.clientAddress, y: &y)
            y += 8  // Slightly increased from 6

            // Project Details
            drawSectionHeader("Project Details", y: &y)
            ensureSpace(20, y: &y); drawKeyValue("Quote Status", quote.quoteStatusRaw.capitalized, y: &y)
            ensureSpace(20, y: &y); drawKeyValue("Created", quote.createdAt.formatted(.medium), y: &y)
            if let completed = quote.completedAt { ensureSpace(20, y: &y); drawKeyValue("Completed", completed.formatted(.medium), y: &y) }
            ensureSpace(20, y: &y); drawKeyValue("Gutter Color", quote.gutterColor, y: &y)
            ensureSpace(20, y: &y); drawKeyValue("Gutter Guard Included", quote.includeGutterGuard ? "Yes" : "No", y: &y)
            if quote.includeGutterGuard { ensureSpace(20, y: &y); drawKeyValue("Gutter Guard Feet", String(format: "%.1f ft", quote.gutterGuardFeet), y: &y) }
            ensureSpace(20, y: &y); drawKeyValue("Profit Margin", percent(quote.profitMarginPercent), y: &y)
            ensureSpace(20, y: &y); drawKeyValue("Sales Commission", percent(quote.salesCommissionPercent), y: &y)
            ensureSpace(20, y: &y); drawKeyValue("Markup", percent(quote.markupPercent), y: &y)
            y += 8

            // Measurements
            ensureSpace(240, y: &y)  // Increased space estimate for larger fonts
            drawSectionHeader("Measurements", y: &y)
            ensureSpace(20, y: &y); drawKeyValue("Gutter Feet", String(format: "%.1f ft", quote.gutterFeet), y: &y)
            ensureSpace(20, y: &y); drawKeyValue("Downspout Feet", String(format: "%.1f ft", quote.downspoutFeet), y: &y)
            ensureSpace(20, y: &y); drawKeyValue("Round Downspout", quote.isRoundDownspout ? "Yes" : "No", y: &y)
            ensureSpace(20, y: &y); drawKeyValue("A Elbows", "\(quote.aElbows)", y: &y)
            ensureSpace(20, y: &y); drawKeyValue("B Elbows", "\(quote.bElbows)", y: &y)
            ensureSpace(20, y: &y); drawKeyValue("2\" Crimp", "\(quote.twoCrimp)", y: &y)
            ensureSpace(20, y: &y); drawKeyValue("4\" Crimp", "\(quote.fourCrimp)", y: &y)
            ensureSpace(20, y: &y); drawKeyValue("End Cap Pairs", "\(quote.endCapPairs)", y: &y)
            ensureSpace(20, y: &y); drawKeyValue("Hangers (auto)", "\(quote.hangersCount)", y: &y)
            ensureSpace(20, y: &y); drawKeyValue("Composite Feet", String(format: "%.1f ft", breakdown.compositeFeet), y: &y)
            y += 8

            // Pricing summary boxes
            ensureSpace(170, y: &y)  // Increased space for larger boxes
            drawSectionHeader("Pricing", y: &y)
// Changed per instructions:
            ensureSpace(260, y: &y) // Updated for increased box height so rows don't overflow
            drawSummaryBoxes(y: &y)

            // Removed separate Subtotal/Markup/Tax rows (now inside left box)

            // Component Totals section (only when gutter guard is enabled)
            if quote.includeGutterGuard && quote.gutterGuardFeet > 0 {
                ensureSpace(120, y: &y)
                drawSectionHeader("Component Totals", y: &y)

                // Use the EXACT calculation method from JobViews.swift Component Totals section (lines 460-500)
                // This gives the correct values: $1,085.57 for gutters and $779.34 for guard
                let _ = quote.gutterFeet + quote.downspoutFeet // gutterFeet not used
                let _ = quote.gutterGuardFeet // guardFeet not used

                // Use the actual breakdown values from PricingEngine and include fittings/hangers in gutters
                let totalElbows = quote.aElbows + quote.bElbows + quote.twoCrimp + quote.fourCrimp
                let elbowUnitCost = quote.isRoundDownspout ? settings.costPerRoundElbow : settings.costPerElbow
                let elbowsCost = Double(totalElbows) * elbowUnitCost
                let hangersCost = Double(quote.hangersCount) * settings.costPerHanger

                let gutterMaterialsCost = breakdown.gutterMaterialsCost + breakdown.downspoutMaterialsCost
                let guardMaterialsCost = breakdown.gutterGuardCost
                let gutterLaborCost = breakdown.gutterLaborCost
                let guardLaborCost = breakdown.gutterGuardLaborCost

                // Base costs
                let gutterBaseCost = gutterMaterialsCost + gutterLaborCost + elbowsCost + hangersCost + breakdown.additionalItemsCost
                let guardBaseCost = guardMaterialsCost + guardLaborCost

                let gutterTotalBeforeAddOns = gutterBaseCost + breakdown.gutterMarkupAmount
                let guardTotalBeforeAddOns = guardBaseCost + breakdown.guardMarkupAmount

                // Distribute only commission and tax proportionally (markup already applied per component)
                let additionalCosts = breakdown.commissionAmount + breakdown.taxAmount

                let totalBaseWithMarkup = gutterTotalBeforeAddOns + guardTotalBeforeAddOns
                let gutterProportion = totalBaseWithMarkup > 0 ? gutterTotalBeforeAddOns / totalBaseWithMarkup : 0.5
                let guardProportion = 1.0 - gutterProportion

                let gutterTotalCost = gutterTotalBeforeAddOns + (additionalCosts * gutterProportion)
                let guardTotalCost = guardTotalBeforeAddOns + (additionalCosts * guardProportion)

                ensureSpace(20, y: &y); drawKeyValue("Gutters Total", currency(gutterTotalCost), y: &y)
                ensureSpace(20, y: &y); drawKeyValue("Guard Total", currency(guardTotalCost), y: &y)
                ensureSpace(20, y: &y); drawKeyValue("Combined Total", currency(gutterTotalCost + guardTotalCost), y: &y)
                y += 8
            }

            // Additional items
            ensureSpace(120, y: &y)
            drawSectionHeader("Additional Labor Items", y: &y)
            if quote.additionalLaborItems.isEmpty {
                ensureSpace(20, y: &y); drawKeyValue("Items", "None", y: &y)
            } else {
                for item in quote.additionalLaborItems {
                    ensureSpace(20, y: &y); drawKeyValue(item.title, currency(item.amount), y: &y)
                }
            }

            // Notes
            if !quote.notes.isEmpty {
                ensureSpace(130, y: &y)
                drawSectionHeader("Notes", y: &y)
                let attrs: [NSAttributedString.Key: Any] = [ .font: valueFont, .foregroundColor: UIColor.black ]
                let notesRect = CGRect(x: margin, y: y, width: contentWidth, height: 110)
                (quote.notes as NSString).draw(in: notesRect, withAttributes: attrs)
                y = notesRect.maxY + 12
            }

            // Terms & Signature
            ensureSpace(100, y: &y)
            drawSectionHeader("Terms & Acceptance", y: &y)
            let terms = "All prices are estimates valid for 30 days. Materials and labor are guaranteed as per company policy."
            let termsAttr: [NSAttributedString.Key: Any] = [ .font: smallFont, .foregroundColor: UIColor.darkGray ]
            (terms as NSString).draw(in: CGRect(x: margin, y: y, width: contentWidth, height: 36), withAttributes: termsAttr)
            y += 40
            ensureSpace(48, y: &y)
            drawSignatureArea(y: &y)

            // Photos (moved to bottom after signature)
            if let photos, !photos.isEmpty, settings.includePhotosInQuote {
                print("📄 PDF Generator: Adding \(photos.count) photos to PDF")
                ensureSpace(24 + 400, y: &y)
                drawSectionHeader("Photos", y: &y)
                let photoHeight: CGFloat = 400
                let spacing: CGFloat = 20

                for (idx, img) in photos.enumerated() {
                    // Check if we need a new page
                    if y + photoHeight + 30 > bottomLimit {
                        newPage(context, &y)
                        ensureSpace(24 + photoHeight, y: &y)
                        if idx == 0 {
                            drawSectionHeader("Photos", y: &y)
                        }
                    }

                    // Calculate photo rect maintaining aspect ratio
                    let rect = CGRect(x: margin, y: y, width: contentWidth, height: photoHeight)
                    let aspect = AVMakeRect(aspectRatio: img.size, insideRect: rect)

                    // Border
                    let path = UIBezierPath(roundedRect: aspect, cornerRadius: 8)
                    UIColor.white.setFill(); path.fill()
                    UIColor.systemGray4.setStroke(); path.lineWidth = 1; path.stroke()
                    img.draw(in: aspect)

                    // Caption
                    let capAttr: [NSAttributedString.Key: Any] = [ .font: smallFont, .foregroundColor: UIColor.darkGray ]
                    ("Photo \(idx + 1)" as NSString).draw(at: CGPoint(x: aspect.minX, y: aspect.maxY + 4), withAttributes: capAttr)

                    y = aspect.maxY + 30 + spacing
                }
            }
        }

        return data
    }

    // MARK: - Quote PDF Generation (Basic, kept for compatibility)
    func generateQuotePDF(breakdown: PricingEngine.PriceBreakdown, customerName: String) -> Data? {
        let pdfRenderer = UIGraphicsPDFRenderer(bounds: CGRect(x: 0, y: 0, width: 612, height: 792))

        return pdfRenderer.pdfData { context in
            context.beginPage()

            let title = "DTS Quote"
            let titleAttributes: [NSAttributedString.Key: Any] = [
                .font: UIFont.boldSystemFont(ofSize: 24),
                .foregroundColor: UIColor.black
            ]

            let bodyAttributes: [NSAttributedString.Key: Any] = [
                .font: UIFont.systemFont(ofSize: 12),
                .foregroundColor: UIColor.black
            ]

            // Title
            title.draw(at: CGPoint(x: 50, y: 50), withAttributes: titleAttributes)

            // Customer Name
            let customerText = "Customer: \(customerName)"
            customerText.draw(at: CGPoint(x: 50, y: 100), withAttributes: bodyAttributes)

            // Date
            let dateText = "Date: \(Date().formatted(.medium))"
            dateText.draw(at: CGPoint(x: 50, y: 130), withAttributes: bodyAttributes)

            // Quote Details with Price Analysis
            let detailsText = """
            Materials: $\(String(format: "%.2f", breakdown.materialsCost))
            Labor: $\(String(format: "%.2f", breakdown.laborCost))
            Subtotal: $\(String(format: "%.2f", breakdown.subtotal))
            Markup: $\(String(format: "%.2f", breakdown.markupAmount))
            Tax: $\(String(format: "%.2f", breakdown.taxAmount))
            Total: $\(String(format: "%.2f", breakdown.totalPrice))

            Price Analysis:
            Total Price/ft: $\(String(format: "%.2f", breakdown.pricePerFoot))/ft
            """

            // Note: In this basic version, we can't easily access quote details to determine
            // if gutter guard is enabled, so we show the standard price per foot
            // The enhanced PDF function should be used for full functionality

            let quoteRect = CGRect(x: 50, y: 160, width: 500, height: 400)
            detailsText.draw(in: quoteRect, withAttributes: bodyAttributes)
        }
    }

    // MARK: - Job Report PDF Generation
    func generateJobReportPDF(job: JobberJob) -> Data? {
        let pdfRenderer = UIGraphicsPDFRenderer(bounds: CGRect(x: 0, y: 0, width: 612, height: 792))

        return pdfRenderer.pdfData { context in
            context.beginPage()

            let title = "Job Report"
            let titleAttributes: [NSAttributedString.Key: Any] = [
                .font: UIFont.boldSystemFont(ofSize: 24),
                .foregroundColor: UIColor.black
            ]

            let bodyAttributes: [NSAttributedString.Key: Any] = [
                .font: UIFont.systemFont(ofSize: 12),
                .foregroundColor: UIColor.black
            ]

            // Title
            title.draw(at: CGPoint(x: 50, y: 50), withAttributes: titleAttributes)

            // Job Details
            let jobDetails = """
            Job ID: \(job.jobId)
            Client: \(job.clientName)
            Address: \(job.address)
            Status: \(job.status)
            Scheduled: \(job.scheduledAt.formatted(.dateTime))

            Generated by DTS App
            Date: \(Date().formatted(.dateTime))
            """

            let jobRect = CGRect(x: 50, y: 100, width: 500, height: 400)
            jobDetails.draw(in: jobRect, withAttributes: bodyAttributes)
        }
    }
    #endif

    // MARK: - Save PDF to Documents
    func savePDFToDocuments(data: Data, filename: String) -> URL? {
        guard let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
            return nil
        }

        let fileURL = documentsURL.appendingPathComponent("\(filename).pdf")

        do {
            try data.write(to: fileURL)
            return fileURL
        } catch {
            print("Error saving PDF: \(error)")
            return nil
        }
    }
}

