//
//  JobberAPI.swift
//  DTS App
//
//  Jobber API integration with OAuth authentication and GraphQL
//

import Foundation
import SwiftUI
import AuthenticationServices
@_exported import UIKit

// MARK: - API Error Types

enum APIError: Error {
    case noToken
    case invalidURL
    case unauthorized
    case invalidResponse
    case graphQLError(String)
}

// MARK: - JobberAPI

@MainActor
class JobberAPI: NSObject, ObservableObject, ASWebAuthenticationPresentationContextProviding {
    @Published var isAuthenticated = false
    @Published var jobs: [JobberJob] = []
    @Published var isLoading = false
    @Published var errorMessage: String?
    @Published var connectedEmail: String?

    // OAuth Configuration
    private let clientId = "bc74e0a3-3f65-4373-b758-a512536ded90"
    private let clientSecret = "c4cc587785949060e4dd052e598a702d0ed8e91410302ceed2702d30413a6c03"
    private let redirectURI = "https://trainingemployer190.github.io/dtsapp-oauth-redirect/"
    private let scopes = "read_clients write_clients read_requests write_requests read_quotes write_quotes read_jobs write_jobs read_scheduled_items write_scheduled_items read_invoices write_invoices read_jobber_payments read_users write_users write_tax_rates read_expenses write_expenses read_custom_field_configurations write_custom_field_configurations read_time_sheets"

    // API Endpoints
    private let authURL = "https://api.getjobber.com/api/oauth/authorize"
    private let tokenURL = "https://api.getjobber.com/api/oauth/token"
    private let apiURL = "https://api.getjobber.com/api/graphql"

    private var authSession: ASWebAuthenticationSession?
    private var storedState: String?

    // Token storage with automatic expiry tracking
    private var accessToken: String? {
        get {
            guard let data = Keychain.load(key: "jobber_access_token") else { return nil }
            return String(data: data, encoding: .utf8)
        }
        set {
            if let token = newValue {
                _ = Keychain.save(key: "jobber_access_token", data: Data(token.utf8))
            } else {
                Keychain.delete(key: "jobber_access_token")
            }
        }
    }

    private var refreshToken: String? {
        get {
            guard let data = Keychain.load(key: "jobber_refresh_token") else { return nil }
            return String(data: data, encoding: .utf8)
        }
        set {
            if let token = newValue {
                _ = Keychain.save(key: "jobber_refresh_token", data: Data(token.utf8))
            } else {
                Keychain.delete(key: "jobber_refresh_token")
            }
        }
    }

    private var tokenExpiry: Date? {
        get {
            let timestamp = UserDefaults.standard.double(forKey: "jobber_token_expiry")
            return timestamp > 0 ? Date(timeIntervalSince1970: timestamp) : nil
        }
        set {
            if let date = newValue {
                UserDefaults.standard.set(date.timeIntervalSince1970, forKey: "jobber_token_expiry")
            } else {
                UserDefaults.standard.removeObject(forKey: "jobber_token_expiry")
            }
        }
    }

    override init() {
        super.init()
        checkAuthenticationStatus()
    }

    private func checkAuthenticationStatus() {
        // Check if we have stored tokens
        if let _ = accessToken, let _ = refreshToken {
            // We have tokens, check if they're still valid
            if let expiry = tokenExpiry, Date() < expiry {
                // Access token is still valid
                isAuthenticated = true
                Task {
                    await fetchAccountInfo()
                }
            } else {
                // Access token expired, try to refresh
                Task {
                    await refreshAccessTokens()
                }
            }
        } else {
            // No tokens stored
            isAuthenticated = false
        }
    }

    func authenticate() {
        // Start fresh OAuth flow
        clearStoredTokens()
        startOAuthFlow()
    }

    private func startOAuthFlow() {
        // Generate random state for security
        storedState = UUID().uuidString

        var urlComponents = URLComponents(string: authURL)!
        urlComponents.queryItems = [
            URLQueryItem(name: "client_id", value: clientId),
            URLQueryItem(name: "redirect_uri", value: redirectURI),
            URLQueryItem(name: "response_type", value: "code"),
            URLQueryItem(name: "scope", value: scopes),
            URLQueryItem(name: "state", value: storedState)
        ]

        guard let authURL = urlComponents.url else {
            self.errorMessage = "Invalid authorization URL."
            return
        }

        // Extract scheme from redirect URI
        let callbackScheme = URL(string: redirectURI)?.scheme ?? "https"

        let authSession = ASWebAuthenticationSession(
            url: authURL,
            callbackURLScheme: callbackScheme
        ) { [weak self] callbackURL, error in
            guard let self = self else { return }

            print("ASWebAuthenticationSession callback received")
            print("Callback URL: \(String(describing: callbackURL))")
            print("Error: \(String(describing: error))")

            if let error = error {
                if case ASWebAuthenticationSessionError.canceledLogin = error {
                    print("User cancelled authentication")
                    return
                }
                Task { @MainActor in
                    self.errorMessage = "Authentication failed: \(error.localizedDescription)"
                }
                return
            }

            guard let callbackURL = callbackURL else {
                Task { @MainActor in
                    self.errorMessage = "Authentication completed but no callback URL was received. Please try again."
                }
                return
            }

            print("Processing callback URL: \(callbackURL.absoluteString)")
            Task {
                await self.handleOAuthCallback(url: callbackURL)
            }
        }

        authSession.presentationContextProvider = self
        authSession.prefersEphemeralWebBrowserSession = false
        self.authSession = authSession

        print("Starting authentication session with:")
        print("- Auth URL: \(authURL.absoluteString)")
        print("- Redirect URI: \(redirectURI)")

        let started = authSession.start()
        print("Authentication session start result: \(started)")

        if !started {
            Task { @MainActor in
                self.errorMessage = "Failed to start authentication session"
            }
        }
    }

    private func handleOAuthCallback(url: URL) async {
        print("=== handleOAuthCallback ===")
        print("Full callback URL: \(url.absoluteString)")

        guard let components = URLComponents(url: url, resolvingAgainstBaseURL: true) else {
            print("Failed to parse URL components")
            await MainActor.run {
                self.errorMessage = "Invalid callback URL format"
            }
            return
        }

        // Validate state
        let receivedState = components.queryItems?.first(where: { $0.name == "state" })?.value
        guard receivedState == storedState else {
            print("State validation failed!")
            await MainActor.run {
                self.errorMessage = "Invalid state parameter - possible security issue"
            }
            return
        }

        // Check for error
        if let error = components.queryItems?.first(where: { $0.name == "error" })?.value {
            await MainActor.run {
                self.errorMessage = "Authorization failed: \(error)"
            }
            return
        }

        // Extract authorization code
        guard let code = components.queryItems?.first(where: { $0.name == "code" })?.value else {
            await MainActor.run {
                self.errorMessage = "No authorization code received"
            }
            return
        }

        // Exchange code for tokens
        await exchangeCodeForTokens(code: code)
    }

    private func exchangeCodeForTokens(code: String) async {
        await MainActor.run {
            self.isLoading = true
            self.errorMessage = nil
        }

        guard let url = URL(string: tokenURL) else {
            await MainActor.run {
                self.errorMessage = "Invalid token URL"
                self.isLoading = false
            }
            return
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type")
        request.setValue("application/json", forHTTPHeaderField: "Accept")
        request.setValue("Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15", forHTTPHeaderField: "User-Agent")
        request.setValue("https://api.getjobber.com", forHTTPHeaderField: "Origin")
        request.setValue("https://api.getjobber.com", forHTTPHeaderField: "Referer")

        var components = URLComponents()
        components.queryItems = [
            URLQueryItem(name: "grant_type", value: "authorization_code"),
            URLQueryItem(name: "client_id", value: clientId),
            URLQueryItem(name: "client_secret", value: clientSecret),
            URLQueryItem(name: "redirect_uri", value: redirectURI),
            URLQueryItem(name: "code", value: code)
        ]

        request.httpBody = components.query?.data(using: .utf8)

        do {
            let (data, response) = try await URLSession.shared.data(for: request)

            if let httpResponse = response as? HTTPURLResponse {
                if httpResponse.statusCode != 200 {
                    let errorText = String(data: data, encoding: .utf8) ?? "Unknown error"
                    await MainActor.run {
                        self.errorMessage = "Token exchange failed (Status \(httpResponse.statusCode)): \(errorText)"
                        self.isLoading = false
                    }
                    return
                }
            }

            let responseString = String(data: data, encoding: .utf8) ?? "Unable to decode response"

            // Check if we got an HTML response (Cloudflare protection)
            if responseString.lowercased().contains("<html") || responseString.lowercased().contains("<!doctype") {
                await MainActor.run {
                    self.isLoading = false
                    self.errorMessage = "Cloudflare protection detected. Please try again."
                }
                return
            }

            // Check if data is empty
            if data.isEmpty {
                await MainActor.run {
                    self.isLoading = false
                    self.errorMessage = "Empty response from server"
                }
                return
            }

            // Try to detect if this is a JSON error response from Jobber
            if let jsonObject = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                if let error = jsonObject["error"] as? String {
                    await MainActor.run {
                        self.isLoading = false
                        self.errorMessage = "OAuth Error: \(error)"
                        if let description = jsonObject["error_description"] as? String {
                            self.errorMessage = "OAuth Error: \(error) - \(description)"
                        }
                    }
                    return
                }
            }

            let tokenResponse = try JSONDecoder().decode(TokenResponse.self, from: data)

            await MainActor.run {
                self.storeTokens(tokenResponse)
                self.isAuthenticated = true
                self.errorMessage = nil
                self.isLoading = false
                self.storedState = nil

                // Fetch account info to verify connection
                Task {
                    await self.fetchAccountInfo()
                }
            }
        } catch {
            await MainActor.run {
                self.errorMessage = "Failed to exchange code for tokens: \(error.localizedDescription)"
                self.isLoading = false
            }
        }
    }

    private func storeTokens(_ tokenResponse: TokenResponse) {
        self.accessToken = tokenResponse.access_token
        self.refreshToken = tokenResponse.refresh_token

        // Set expiry with 60 second buffer - default to 1 hour if not provided
        let expiresIn = tokenResponse.expires_in ?? 3600
        let expiryDate = Date().addingTimeInterval(TimeInterval(expiresIn - 60))
        self.tokenExpiry = expiryDate

        print("Tokens stored successfully. Access token expires at: \(expiryDate)")
    }

    private func refreshAccessTokens() async {
        guard let refreshToken = self.refreshToken else {
            await MainActor.run {
                self.signOut()
            }
            return
        }

        guard let url = URL(string: tokenURL) else { return }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type")
        request.setValue("application/json", forHTTPHeaderField: "Accept")
        request.setValue("Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15", forHTTPHeaderField: "User-Agent")
        request.setValue("https://api.getjobber.com", forHTTPHeaderField: "Origin")
        request.setValue("https://api.getjobber.com", forHTTPHeaderField: "Referer")

        var components = URLComponents()
        components.queryItems = [
            URLQueryItem(name: "grant_type", value: "refresh_token"),
            URLQueryItem(name: "client_id", value: clientId),
            URLQueryItem(name: "client_secret", value: clientSecret),
            URLQueryItem(name: "refresh_token", value: refreshToken)
        ]

        request.httpBody = components.query?.data(using: .utf8)

        do {
            let (data, response) = try await URLSession.shared.data(for: request)

            if let httpResponse = response as? HTTPURLResponse {
                if httpResponse.statusCode == 401 || httpResponse.statusCode == 400 {
                    await MainActor.run {
                        self.errorMessage = "Session expired. Please reconnect your Jobber account."
                        self.signOut()
                    }
                    return
                } else if httpResponse.statusCode != 200 {
                    let errorText = String(data: data, encoding: .utf8) ?? "Unknown error"
                    await MainActor.run {
                        self.errorMessage = "Token refresh failed: \(errorText)"
                        self.signOut()
                    }
                    return
                }
            }

            let tokenResponse = try JSONDecoder().decode(TokenResponse.self, from: data)

            await MainActor.run {
                self.storeTokens(tokenResponse)
                self.isAuthenticated = true
                self.errorMessage = nil
            }

        } catch {
            await MainActor.run {
                self.errorMessage = "Failed to refresh tokens. Please reconnect your account."
                self.signOut()
            }
        }
    }

    private func ensureValidAccessToken() async -> Bool {
        // Check if access token is expired
        if let expiry = tokenExpiry, Date() >= expiry {
            // Token is expired, try to refresh
            await refreshAccessTokens()
        }

        return isAuthenticated && accessToken != nil
    }

    private func fetchAccountInfo() async {
        guard await ensureValidAccessToken(), let _ = accessToken else { return }

        let query = """
        query GetAccountInfo {
          account {
            id
            name
          }
        }
        """

        await performGraphQLRequest(query: query, variables: [:]) { [weak self] (result: Result<AccountResponse, Error>) in
            Task { @MainActor in
                switch result {
                case .success(let response):
                    self?.connectedEmail = response.data.account.name
                    print("Successfully connected as: \(response.data.account.name)")
                case .failure(let error):
                    print("Failed to fetch account info: \(error)")
                }
            }
        }
    }

    func fetchScheduledAssessments() async {
        guard await ensureValidAccessToken() else {
            await MainActor.run {
                self.errorMessage = "Please connect your Jobber account first"
            }
            return
        }

        await MainActor.run {
            isLoading = true
            errorMessage = nil
        }

        let today = Date()
        let calendar = Calendar.current

        // Get current date at start of day
        let startOfDay = calendar.startOfDay(for: today)
        // Get date 7 days from now
        let endDate = calendar.date(byAdding: .day, value: 7, to: startOfDay) ?? today
        let endOfWeek = calendar.date(bySettingHour: 23, minute: 59, second: 59, of: endDate) ?? endDate

        let isoFormatter = ISO8601DateFormatter()
        isoFormatter.timeZone = TimeZone(secondsFromGMT: 0)
        let weekStart = isoFormatter.string(from: startOfDay)
        let weekEnd = isoFormatter.string(from: endOfWeek)

        print("Fetching scheduled assessments for next 7 days")
        print("Date range: \(weekStart) to \(weekEnd)")

        // Try a simpler query first to see if we can get any data
        let query = """
        query getScheduledAssessments($start: ISO8601DateTime!, $end: ISO8601DateTime!, $first: Int!) {
          scheduledItems(
            filter: {
              scheduleItemType: ASSESSMENT
              occursWithin: { startAt: $start, endAt: $end }
            }
            first: $first
          ) {
            nodes {
              ... on Assessment {
                id
                title
                startAt
                endAt
                completedAt
                client {
                  id
                  name
                }
                property {
                  address {
                    street1
                    city
                    province
                  }
                }
                assignedUsers {
                  nodes {
                    name {
                      full
                    }
                  }
                }
              }
            }
            pageInfo {
              hasNextPage
              endCursor
            }
            totalCount
          }
        }
        """

        let variables: [String: Any] = [
            "start": weekStart,
            "end": weekEnd,
            "first": 10
        ]

        print("About to make GraphQL request with variables: \(variables)")

        await performGraphQLRequest(query: query, variables: variables) { [weak self] (result: Result<ScheduledAssessmentsResponse, Error>) in
            Task { @MainActor in
                guard let self = self else { return }
                self.isLoading = false

                print("GraphQL request completed")

                switch result {
                case .success(let response):
                    var fetchedJobs: [JobberJob] = []

                    print("SUCCESS: Found \(response.data.scheduledItems.nodes.count) scheduled assessments")

                    if response.data.scheduledItems.nodes.isEmpty {
                        print("No assessments found in the specified date range")
                        print("Trying to fetch all scheduled items without date filter...")

                        // If no items found with date filter, try without filter
                        await self.fetchAllScheduledItems()
                        return
                    }

                    for assessment in response.data.scheduledItems.nodes {
                        print("Processing assessment: \(assessment.id)")
                        print("Assessment title: \(assessment.title ?? "No title")")
                        print("Assessment startAt: \(assessment.startAt)")

                        guard let startAt = self.parseDate(assessment.startAt) else {
                            print("Could not parse start date: \(assessment.startAt)")
                            continue
                        }

                        let clientName = assessment.client.name
                        let title = assessment.title ?? "Assessment"
                        let _ = assessment.assignedUsers.nodes.map { $0.name.full }.joined(separator: ", ")

                        // Extract primary phone number
                        let clientPhone: String? = assessment.client.phones?.first(where: { $0.primary })?.number ?? assessment.client.phones?.first?.number

                        // Build address from property
                        let address: String
                        if let property = assessment.property?.address {
                            var addressComponents: [String] = []
                            if let street = property.street1, !street.isEmpty {
                                addressComponents.append(street)
                            }
                            if let city = property.city, !city.isEmpty {
                                addressComponents.append(city)
                            }
                            if let province = property.province, !province.isEmpty {
                                addressComponents.append(province)
                            }
                            address = addressComponents.joined(separator: ", ")
                        } else {
                            address = "Address not available"
                        }

                        // Determine status
                        let status: String
                        if assessment.completedAt != nil {
                            status = "completed"
                        } else if startAt <= Date() {
                            status = "in_progress"
                        } else {
                            status = "scheduled"
                        }

                        // Create JobberJob
                        let jobberJob = JobberJob(
                            jobId: assessment.id,
                            clientName: clientName,
                            address: address,
                            scheduledAt: startAt,
                            status: status
                        )

                        fetchedJobs.append(jobberJob)
                        print("Added assessment: \(clientName) - \(title) at \(startAt) (\(status))")
                    }

                    self.jobs = fetchedJobs
                    print("Successfully fetched \(fetchedJobs.count) scheduled assessments for this week")

                case .failure(let error):
                    print("FAILED to fetch scheduled assessments: \(error)")
                    print("Error type: \(type(of: error))")
                    if let apiError = error as? APIError {
                        switch apiError {
                        case .graphQLError(let message):
                            print("GraphQL Error: \(message)")
                        case .noToken:
                            print("No authentication token available")
                        case .invalidURL:
                            print("Invalid URL")
                        case .unauthorized:
                            print("Unauthorized - token may be expired")
                        case .invalidResponse:
                            print("Invalid response from server")
                        }
                    }
                    self.errorMessage = error.localizedDescription
                }
            }
        }
    }

    func fetchAllScheduledItems() async {
        guard await ensureValidAccessToken() else {
            await MainActor.run {
                self.errorMessage = "Please connect your Jobber account first"
            }
            return
        }

        print("Fetching ALL scheduled items (no date filter)...")

        let query = """
        query getAllScheduledItems($first: Int!) {
          scheduledItems(first: $first) {
            nodes {
              ... on Assessment {
                id
                title
                startAt
                endAt
                completedAt
                client {
                  id
                  name
                }
                property {
                  address {
                    street1
                    city
                    province
                  }
                }
              }
            }
            pageInfo {
              hasNextPage
              endCursor
            }
            totalCount
          }
        }
        """

        let variables: [String: Any] = [
            "first": 50
        ]

        print("About to make GraphQL request for ALL scheduled items")

        await performGraphQLRequest(query: query, variables: variables) { [weak self] (result: Result<ScheduledAssessmentsResponse, Error>) in
            Task { @MainActor in
                guard let self = self else { return }

                print("GraphQL request for ALL items completed")

                switch result {
                case .success(let response):
                    var fetchedJobs: [JobberJob] = []

                    print("SUCCESS: Found \(response.data.scheduledItems.nodes.count) total scheduled items")

                    for assessment in response.data.scheduledItems.nodes {
                        print("Processing item: \(assessment.id)")
                        print("Item title: \(assessment.title ?? "No title")")
                        print("Item startAt: \(assessment.startAt)")

                        guard let startAt = self.parseDate(assessment.startAt) else {
                            print("Could not parse start date: \(assessment.startAt)")
                            continue
                        }

                        let clientName = assessment.client.name
                        let title = assessment.title ?? "Assessment"

                        // Extract primary phone number
                        let clientPhone: String? = assessment.client.phones?.first(where: { $0.primary })?.number ?? assessment.client.phones?.first?.number

                        // Build address from property
                        let address: String
                        if let property = assessment.property?.address {
                            var addressComponents: [String] = []
                            if let street = property.street1, !street.isEmpty {
                                addressComponents.append(street)
                            }
                            if let city = property.city, !city.isEmpty {
                                addressComponents.append(city)
                            }
                            if let province = property.province, !province.isEmpty {
                                addressComponents.append(province)
                            }
                            address = addressComponents.joined(separator: ", ")
                        } else {
                            address = "Address not available"
                        }

                        // Determine status
                        let status: String
                        if assessment.completedAt != nil {
                            status = "completed"
                        } else if startAt <= Date() {
                            status = "in_progress"
                        } else {
                            status = "scheduled"
                        }

                        // Create JobberJob
                        let jobberJob = JobberJob(
                            jobId: assessment.id,
                            clientName: clientName,
                            address: address,
                            scheduledAt: startAt,
                            status: status
                        )

                        fetchedJobs.append(jobberJob)
                        print("Added item: \(clientName) - \(title) at \(startAt) (\(status))")
                    }

                    self.jobs = fetchedJobs
                    print("Successfully fetched \(fetchedJobs.count) total scheduled items")

                case .failure(let error):
                    print("FAILED to fetch all scheduled items: \(error)")
                    self.errorMessage = "Failed to fetch scheduled items: \(error.localizedDescription)"
                }
            }
        }
    }

    func fetchWeekScheduledRequests() async {
        guard await ensureValidAccessToken() else {
            await MainActor.run {
                self.errorMessage = "Please connect your Jobber account first"
            }
            return
        }

        await MainActor.run {
            isLoading = true
            errorMessage = nil
        }

        let today = Date()
        let calendar = Calendar.current

        // Debug: Print the current date we're working with
        print("Current date: \(today)")
        print("Calendar: \(calendar.identifier)")

        // Get the start of today
        let startOfToday = calendar.startOfDay(for: today)

        // Get the end date (7 days from today)
        guard let endDate = calendar.date(byAdding: .day, value: 7, to: startOfToday) else {
            print("Failed to calculate end date")
            return
        }

        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd"
        dateFormatter.timeZone = TimeZone.current // Use current timezone
        let weekStartString = dateFormatter.string(from: startOfToday)
        let weekEndString = dateFormatter.string(from: endDate)

        print("Week start: \(startOfToday)")
        print("Week end: \(endDate)")
        print("Fetching scheduled items for this week (\(weekStartString) to \(weekEndString))")

        // Query for scheduled assessments this week
        let query = """
        query getScheduledAssessments($start: ISO8601DateTime!, $end: ISO8601DateTime!, $first: Int!) {
          scheduledItems(
            filter: {
              scheduleItemType: ASSESSMENT
              occursWithin: { startAt: $start, endAt: $end }
            }
            first: $first
          ) {
            nodes {
              ... on Assessment {
                id
                title
                startAt
                endAt
                completedAt
                client {
                  id
                  name
                  firstName
                  lastName
                  companyName
                  emails {
                    address
                    description
                    primary
                  }
                  phones {
                    number
                    description
                    primary
                  }
                  billingAddress {
                    street1
                    city
                    province
                    postalCode
                  }
                }
                property {
                  address {
                    street1
                    city
                    province
                  }
                }
                assignedUsers {
                  nodes {
                    name {
                      full
                    }
                  }
                }
              }
            }
            pageInfo {
              hasNextPage
              endCursor
            }
            totalCount
          }
        }
        """

        // Use ISO format for GraphQL variables
        let isoFormatter = ISO8601DateFormatter()
        isoFormatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]

        let variables: [String: Any] = [
            "start": isoFormatter.string(from: startOfToday),
            "end": isoFormatter.string(from: endDate),
            "first": 10
        ]

        print("GraphQL variables: \(variables)")

        await performGraphQLRequest(query: query, variables: variables) { [weak self] (result: Result<ScheduledAssessmentsResponse, Error>) in
            Task { @MainActor in
                guard let self = self else { return }
                self.isLoading = false

                switch result {
                case .success(let response):
                    var fetchedJobs: [JobberJob] = []

                    print("Found \(response.data.scheduledItems.nodes.count) assessments from GraphQL query (should be filtered to this week)")

                    // Since we're filtering at the GraphQL level, all returned assessments should be in range
                    for assessment in response.data.scheduledItems.nodes {
                        let clientName = assessment.client.name
                        let title = assessment.title ?? "Assessment"
                        let startAtString = assessment.startAt

                        // Extract primary phone number
                        let clientPhone: String? = assessment.client.phones?.first(where: { $0.primary })?.number ?? assessment.client.phones?.first?.number

                        // Debug: print all assessments we get back
                        print("Processing assessment: \(clientName) - \(title) at \(startAtString)")

                        guard let startAt = self.parseDate(startAtString) else {
                            print("Failed to parse date for assessment: \(startAtString)")
                            continue
                        }

                        // Build address from property or billing address
                        let address: String
                        if let propertyAddress = assessment.property?.address {
                            var addressComponents: [String] = []
                            if let street = propertyAddress.street1, !street.isEmpty {
                                addressComponents.append(street)
                            }
                            if let city = propertyAddress.city, !city.isEmpty {
                                addressComponents.append(city)
                            }
                            if let province = propertyAddress.province, !province.isEmpty {
                                addressComponents.append(province)
                            }
                            address = addressComponents.joined(separator: ", ")
                        } else if let billingAddress = assessment.client.billingAddress {
                            var addressComponents: [String] = []
                            if let street = billingAddress.street1, !street.isEmpty {
                                addressComponents.append(street)
                            }
                            if let city = billingAddress.city, !city.isEmpty {
                                addressComponents.append(city)
                            }
                            if let province = billingAddress.province, !province.isEmpty {
                                addressComponents.append(province)
                            }
                            address = addressComponents.joined(separator: ", ")
                        } else {
                            address = "Address not available"
                        }

                        // Determine status
                        let status: String
                        if assessment.completedAt != nil {
                            status = "completed"
                        } else if startAt <= Date() {
                            status = "in_progress"
                        } else {
                            status = "scheduled"
                        }

                        // Create JobberJob for all returned assessments (they should all be in range)
                        let job = JobberJob(
                            jobId: assessment.id,
                            clientName: clientName,
                            address: address,
                            scheduledAt: startAt,
                            status: status
                        )
                        fetchedJobs.append(job)
                        print("Added assessment: \(job.clientName) at \(job.scheduledAt)")
                    }

                    self.jobs = fetchedJobs
                    print("Fetched \(fetchedJobs.count) scheduled assessments for this week")

                    if fetchedJobs.isEmpty {
                        print("No assessments found for this week after GraphQL filtering.")
                    }

                case .failure(let error):
                    print("Failed to fetch visits: \(error)")
                    self.errorMessage = error.localizedDescription
                }
            }
        }
    }

    func createQuoteDraft(quoteDraft: QuoteDraft) async {
        guard await ensureValidAccessToken() else {
            await MainActor.run {
                self.errorMessage = "Please connect your Jobber account first"
            }
            return
        }

        await MainActor.run {
            isLoading = true
            errorMessage = nil
        }

        let lineItems = quoteDraft.lineItemsForJobber.map { item in
            [
                "name": item.name,
                "description": item.description,
                "quantity": item.quantity,
                "unitCost": item.unitPrice
            ]
        }

        let variables: [String: Any] = [
            "input": [
                "clientId": quoteDraft.clientId ?? "",
                "title": "Gutter Installation Quote",
                "lineItems": lineItems
            ]
        ]

        let mutation = """
        mutation CreateQuote($input: QuoteCreateInput!) {
          quoteCreate(input: $input) {
            quote {
              id
              title
            }
            userErrors {
              field
              message
            }
          }
        }
        """

        await performGraphQLRequest(query: mutation, variables: variables) { [weak self] (result: Result<QuoteCreateResponse, Error>) in
            Task { @MainActor in
                guard let self = self else { return }
                self.isLoading = false

                switch result {
                case .success(let response):
                    if let userErrors = response.data.quoteCreate.userErrors, !userErrors.isEmpty {
                        let errors = userErrors.map { $0.message }.joined(separator: ", ")
                        self.errorMessage = "Quote creation failed: \(errors)"
                    } else {
                        self.errorMessage = nil
                        print("Quote created successfully")
                    }
                case .failure(let error):
                    self.errorMessage = "Failed to create quote: \(error.localizedDescription)"
                }
            }
        }
    }

    private func performGraphQLRequest<T: Codable>(
        query: String,
        variables: [String: Any],
        completion: @escaping (Result<T, Error>) -> Void
    ) async {
        guard let token = accessToken else {
            completion(.failure(APIError.noToken))
            return
        }

        guard let url = URL(string: apiURL) else {
            completion(.failure(APIError.invalidURL))
            return
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        request.setValue("Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15", forHTTPHeaderField: "User-Agent")
        request.setValue("https://api.getjobber.com", forHTTPHeaderField: "Origin")
        request.setValue("https://api.getjobber.com", forHTTPHeaderField: "Referer")
        request.setValue("2025-01-20", forHTTPHeaderField: "X-JOBBER-GRAPHQL-VERSION")

        let body: [String: Any] = [
            "query": query,
            "variables": variables
        ]

        do {
            request.httpBody = try JSONSerialization.data(withJSONObject: body)

            let (data, response) = try await URLSession.shared.data(for: request)

            // Check for GraphQL errors in response
            if let jsonObject = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                if let errors = jsonObject["errors"] as? [[String: Any]] {
                    let errorMessages = errors.compactMap { $0["message"] as? String }
                    completion(.failure(APIError.graphQLError(errorMessages.joined(separator: ", "))))
                    return
                }

                if jsonObject["data"] == nil {
                    completion(.failure(APIError.invalidResponse))
                    return
                }
            }

            if let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 401 {
                // Token expired, try to refresh and retry once
                await refreshAccessTokens()

                if isAuthenticated, let newToken = accessToken {
                    // Retry with new token
                    request.setValue("Bearer \(newToken)", forHTTPHeaderField: "Authorization")
                    let (retryData, _) = try await URLSession.shared.data(for: request)
                    let result = try JSONDecoder().decode(T.self, from: retryData)
                    completion(.success(result))
                } else {
                    completion(.failure(APIError.unauthorized))
                }
                return
            }

            let result = try JSONDecoder().decode(T.self, from: data)
            completion(.success(result))
        } catch {
            completion(.failure(error))
        }
    }

    private func parseDate(_ dateString: String) -> Date? {
        let formatter = ISO8601DateFormatter()
        return formatter.date(from: dateString)
    }

    private func clearStoredTokens() {
        accessToken = nil
        refreshToken = nil
        tokenExpiry = nil
        connectedEmail = nil
    }

    func signOut() {
        clearStoredTokens()
        isAuthenticated = false
        jobs = []
        errorMessage = nil
    }

    private func createJobberJobFromVisit(visit: VisitWithJobNode, scheduledAt: Date, status: String) -> JobberJob {
        let clientName = visit.job.client.name
        let address = formatVisitAddress(visit)
        
        // Note: Visit data doesn't include client phone numbers in the current GraphQL query
        // This could be enhanced in future to fetch phone numbers for visits as well
        let jobberJob = JobberJob(
            jobId: visit.job.id,
            clientName: clientName,
            clientPhone: nil,
            address: address,
            scheduledAt: scheduledAt,
            status: status
        )

        return jobberJob
    }

    private func formatVisitAddress(_ visit: VisitWithJobNode) -> String {
        if let propertyAddress = visit.job.property?.address {
            var addressParts: [String] = []
            if let street1 = propertyAddress.street1, !street1.isEmpty {
                addressParts.append(street1)
            }
            if let city = propertyAddress.city, !city.isEmpty {
                addressParts.append(city)
            }
            return addressParts.isEmpty ? "No address available" : addressParts.joined(separator: ", ")
        }
        return "No address available"
    }

    // MARK: - ASWebAuthenticationPresentationContextProviding
    func presentationAnchor(for session: ASWebAuthenticationSession) -> ASPresentationAnchor {
        // Return the key window for presenting the authentication session
        guard let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
              let window = windowScene.windows.first else {
            return ASPresentationAnchor()
        }
        return window
    }
}

// MARK: - Response Models for Visits
struct VisitsResponse: Codable {
    let data: VisitsData
}

struct VisitsData: Codable {
    let visits: VisitsConnection
}

struct VisitsConnection: Codable {
    let nodes: [VisitWithJobNode]
}

struct VisitWithJobNode: Codable {
    let id: String
    let startAt: String?
    let endAt: String?
    let job: SimpleJobNode
}

struct SimpleJobNode: Codable {
    let id: String
    let title: String?
    let client: ClientNode
    let property: PropertyNode?
}

struct ClientNode: Codable {
    let name: String
}

struct PropertyNode: Codable {
    let address: PropertyAddress?
}

struct PropertyAddress: Codable {
    let street1: String?
    let city: String?
}
